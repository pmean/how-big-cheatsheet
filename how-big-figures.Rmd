---
title: "How-Big-Cheatsheet"
author: "Steve Simon"
date: "September 17, 2016"
output: html_document
---

```{r prelims, echo=FALSE}
# Note: once I am done with this, I need to do a cheat sheet on date-time values in R.

x <- function(p) {
  marks <- c(-1, 0, 0.82, 7-0.42, 7, 7)
  p <- ifelse (p < 100, 100, p)
  p <- ifelse (p > 500, 500, p)
  i <- p %/% 100
  w <- (p/100) %% 1
  return((1-w)*marks[i]+w*marks[i+1])
}

y <- function(p) {
  marks <- c(-1, 0, 1.02, 7-0.82, 7, 7)
  p <- ifelse (p < 100, 100, p)
  p <- ifelse (p > 500, 500, p)
  i <- p %/% 100
  w <- (p/100) %% 1
  return((1-w)*marks[i]+w*marks[i+1])
}

# Start with the assumption that the graph is seven inches by seven inches
# and that mar=c(5.1, 4.1, 4.1, 2.1) and mai=c(1.02, 0.82, 0.82, 0.42)
# which means 5 lines per inch. Also assume that there are 96 pixels per inch.


draw_framework <- function() {
  par(mar=rep(0, 4), xaxs="i", yaxs="i")
  plot(c(-1,7.1), c(-1,7.1), type="n", axes=FALSE)

  # user coordinates after adding 4%
  polygon(
    x=x(c(300, 400, 400, 300)),
    y=y(c(300, 300, 400, 400)),
    density=NA, col="olivedrab", border="black")

  # user coordinates defined by xlim, ylim
  polygon(
    x=x(c(304, 396, 396, 304)),
    y=y(c(304, 304, 396, 396)),
    density=NA, col="olivedrab1", border="black", lty="dotted")

  axis(side=1, pos=y(300), at=x(c(304, 396)), labels=rep(" ", 2), lwd=3) 
  axis(side=2, pos=x(300), at=y(c(304, 396)), labels=rep(" ", 2), lwd=3) 

  polygon(x=x(c(200, 500, 500, 200)), y=y(c(200, 200, 500, 500)), lwd=3, lty="dashed")
}
```

# How Big is My Graph?

## An R Cheatsheet

All functions that open a device for graphics will have height and width arguments to control the size of the graph and a pointsize argument to control the relative font size. In knitr, you control the size of the graph with the chunk options, fig.width and fig.height. This sheet will help you with calculating the size of the graph and various parts of the graph within R.

```{r device_size, fig.width=5.25, fig.height=5.25, echo=FALSE}
din <- function() {
  # graphics device size (x)
  s1 <- "dev.size()[1] (in, cm, px), din[1] (in)"
  w1 <- strwidth(s1)
  text    (x(304),    y(150), s1, adj=0)
  arrows  (x(300),    y(150), x(200), y(150), lwd=3, len=0.05)
  arrows  (x(308)+w1, y(150), x(500), y(150), lwd=3, len=0.05)
  segments(x(200),    y(190), x(200), y(110), lwd=3)
  segments(x(500),    y(190), x(500), y(110), lwd=3)
  
  # graphics device size (y)
  s2 <- "dev.size()[2] (in, cm, px), din[2] (in)"
  w2 <- strwidth(s2)
  text    (x(150), y(304), s2, adj=0, srt=90)
  arrows  (x(150), y(300),    x(150), y(200), lwd=3, len=0.05)
  arrows  (x(150), y(308)+w2, x(150), y(500), lwd=3, len=0.05)
  segments(x(190), y(200),    x(110), y(200), lwd=3)
  segments(x(190), y(500),    x(110), y(500), lwd=3)
}
draw_framework()
din()
```

## Device size

**dev.size(units)** (width, height) 

**par("din")** *(r.o.)* (width, height) in inches

Both the **dev.size** function or **par("din")** will tell you the size of the graphics device, but **par("din")** will not be updated if you resize your graphics window. The **dev.size** function will report the size in

1. inches (**unit="in"**), the default

2. centimeters (**units="cm"**)

3. pixels (**units="px"**)

Like several other **par** arguments, **din** is read only (r.o.) meaning that you cannot assign a value to it.

```{r margins, fig.width=5.25, fig.height=5.25, echo=FALSE}
mar <- function() {
  # bottom margin
  arrows  (x(308), y(200), x(308), y(300), lwd=3, length=0.05, code=3)
  segments(x(308), y(233), x(314), y(233), lwd=3)
  text(    x(318), y(233), "mai[1] (in), mar[1] (lines)", adj=0, cex=1.0)
  
  # top margin
  arrows  (x(392), y(400), x(392), y(500), lwd=3, length=0.05, code=3)
  segments(x(392), y(467), x(360), y(467), lwd=3)
  text    (x(356), y(467), "mai[3] (in), nmar[3] (lines)", adj=1, cex=1.0)
  
  # left margin
  arrows  (x(200), y(392), x(300), y(392), lwd=3, len=0.05, code=3)
  segments(x(250), y(392), x(250), y(386), lwd=3)
  text    (x(250), y(382), "mai[2] (in), mar[2] (lines)", adj=1, srt=90)
  
  # right margin
  arrows  (x(400), y(308), x(500), y(308), lwd=3, length=0.05, code=3)
  segments(x(450), y(308), x(450), y(340), lwd=3)
  text    (x(450), y(344), "mai[4] (in), mar[4] (lines)", adj=0, srt=90, cex=1.0)
}
draw_framework()
mar()
```

## Margins

**par("mai")** -> (bottom, left, top, right) in inches

**par("mar")** -> (bottom, left, top, right) in lines

Margins provide you space for your axes, axis, labels, and titles.

If your graph has no axes or titles, you can remove the margins (and maximize the plotting region) with

**par(mar=rep(0,4))**

## Help!! My title or axis labels won't fit.

There are several possible solutions.

1. You can assign wider margins using the **mar** or **mai** argument in **par**.

2. You can change the orientation of the axis labels with the **las**. Choose among 

a. **las=0** both axis labels parallel

b. **las=1** both axis labels horizontal

c. **las=2** both axis labels perpendicular

d. **las=3** both axis labels vertical

3. change the relative size of the font

a. **cex.axis** for the tick mark labels.

b. **cex.lab** for **xlab** and **ylab**.

c. **cex.main** for the main title

d. **cex.sub** for the subtitle.

```{r usr, fig.width=5.25, fig.height=5.25, echo=FALSE}
usr <- function() {
  # lower left user coordinates
  arrows  (x(267), y(267), x(300), y(300), lwd=3, len=0.05)
  segments(x(267), y(267), x(308), y(267), lwd=3)
  text    (x(312), y(267), "usr[c(1,3)] (user)", adj=0)
  
  # upper right user coordinates
  arrows  (x(433), y(433), x(400), y(400), lwd=3, len=0.05)
  segments(x(433), y(433), x(360), y(433), lwd=3)
  text    (x(356), y(433), "usr[c(2,4)] (user)", adj=1)
}
draw_framework()
usr()
```

## User coordinates

**par("usr")** -> (xmin, ymin, xmax, ymax)

User coordinates are the values you use when plotting your data. Run par("usr") to get a vector of length 4 with the user coordinates with the minimum X value, the maximum X value, the minimum Y value, and the maximum Y value. This normally is not the same as the values specified by the xlim and ylim arguments in plot. By default, R adds and extra 4% to the plotting range so that points right on the edge do not get partially clipped. You can override this using the **xaxs="i"** and/or the **yaxs="i"** arguments in par.


```{r region, fig.width=5.25, fig.height=5.25, echo=FALSE}
pin <- function() {
  # plotting region size (x--pin[1], plt[1], plt[2])
  s3 <- "pin[1] (in)"
  w3 <- strwidth(s3)
  text  (x(312),    y(330), s3, adj=0)
  arrows(x(308),    y(330), x(300), y(330), lwd=3, len=0.05)
  arrows(x(316)+w3, y(330), x(400), y(330), lwd=3, len=0.05)
  
  s4 <- "plt[1] (pct)"
  w4 <- strwidth(s4)
  text    (x(312), y(310), s4, adj=0)
  arrows  (x(200), y(310), x(300),    y(310), lwd=3, len=0.05)
  segments(x(300), y(310), x(308),    y(310), lwd=3, lty="dotted")
  segments(x(500), y(310), x(316)+w4, y(310), lwd=3, lty="dotted")
  
  s5 <- "plt[2] (pct)"
  w5 <- strwidth(s5)
  text    (x(312),    y(320), s5, adj=0)
  segments(x(200),    y(320), x(308), y(320), lwd=3)
  arrows  (x(316)+w5, y(320), x(400), y(320), lwd=3, len=0.05)
  segments(x(400),    y(320), x(500), y(320), lwd=3, lty="dotted")
  
  s6 <- "pin[2] (in)"
  w6 <- strwidth(s6)
  arrows(x(390), y(371)-w6, x(390), y(300), lwd=3, len=0.05)
  arrows(x(390), y(379),    x(390), y(400), lwd=3, len=0.05)
  text  (x(390), y(375), s6, adj=1, srt=90)
  
  # plotting region size (x--pin[1], plt[1], plt[2])
  s7 <- "plt[4] (pct)"
  w7 <- strwidth(s7)
  text    (x(380), y(375), s7, adj=1, srt=90)
  segments(x(380), y(200), x(380), y(371)-w7, lwd=3)
  arrows  (x(380), y(379), x(380), y(400),    lwd=3, len=0.05)
  segments(x(380), y(400), x(380), y(500),    lwd=3, lty="dotted")
  
  s8 <- "plt[3] (pct)"
  w8 <- strwidth(s8)
  text    (x(370), y(375), s8, adj=1, srt=90)
  segments(x(370), y(200), x(370), y(371)-w7, lwd=3, lty="dotted")
  arrows  (x(370), y(200), x(370), y(300),    lwd=3, len=0.05)
  segments(x(370), y(379), x(370), y(500),    lwd=3, lty="dotted")
}
draw_framework()
pin()
```

## Plotting region in inches and percent

**par("pin")** -> (width, height) in inches

**par("plt")** -> (left, right, bottom, top) in percent

The **pin** argument in **par** gives you the size of the plotting region (the size of the device minus the size of the margins) in inches.

The **plt** argument gives you the percentage of the device up to the left edge of the plotting region, the right edge, the bottom edge, and the top edge. The first and third values are equivalent to the percentage of space deveoted to the left and bottom margins. Subtract the second and fourth values from 1 to get the percentage of space devoted to the right and top margins.

## Getting a square graph

You can produce a square graph manually by setting the width and height to the same value and setting the margins so that the sum of the top and bottom margins equal the sum of the left and right margins. But a much easier way is to specify **pty="s"**, which adjusts the margins so that the size of the plotting region is always square, even if you resize the graphics window.

# String size

```{r strwidth, fig.width=5.25, fig.height=5.25, echo=FALSE}
draw_multiline <- function() {
text(x(325), y(378), "Abcde\nFghij\nKlmno", cex=2)
  u0 <<- strheight("M")
  u1 <<- strheight("M\nM") - strheight("M")
  u  <<- y(378) + c(2, 2, 0, 0, -2, -2)*u1 + c(1, -1, 1, -1, 1, -1)*u0
  u12 <<- (u[1]+u[2])/2
  u34 <<- (u[3]+u[4])/2
  u56 <<- (u[5]+u[6])/2
  u7  <<- u[6]-u0
  segments(x(308), u, x(392), u, lty="dotted")
}
ht <- function() {
  text(x(390), u12, 'strheight("M")', adj=1)
  text(x(390), u34, 'strheight("M\\nM")', adj=1)
  text(x(390), u56, 'strheight("M\\nM\\nM")', adj=1)
  arrows  (x(355), u[1], x(355), u[2], lwd=3, len=0.05, code=3)
  arrows  (x(350), u[1], x(350), u[4], lwd=3, len=0.05, code=3)
  arrows  (x(345), u[1], x(345), u[6], lwd=3, len=0.05, code=3)
  segments(x(355),  u12, x(362),  u12, lwd=3)
  segments(x(350),  u34, x(354),  u34, lwd=3)
  segments(x(345),  u56, x(347),  u56, lwd=3)
}
wi <- function() {
  text(x(320), y(345), "W", cex=2)
  u <- strwidth("W")
  v <- strheight("W")
  segments(x(320)-u, y(345)+1.5*v, x(320)-u,  y(345)-2.0*v, lty="dotted")
  segments(x(320)+u, y(345)+1.5*v, x(320)+u,  y(345)-2.0*v, lty="dotted")
  arrows  (x(320)+u, y(345)-1.5*v, x(320)-u,  y(345)-1.5*v, len=0.05, lwd=3, code=3)
  segments(x(320), y(345)-1.5*v, x(320), y(335)+0.5*v, lwd=3)
  
  text(x(340), y(345), "L", cex=2)
  u <- strwidth("L")
  segments(x(340)-u, y(345)+1.5*v, x(340)-u,  y(345)-2.0*v, lty="dotted")
  segments(x(340)+u, y(345)+1.5*v, x(340)+u,  y(345)-2.0*v, lty="dotted")
  arrows  (x(340)+u, y(345)-1.5*v, x(340)-u,  y(345)-1.5*v, len=0.05, lwd=3, code=3)
  segments(x(340), y(345)-1.5*v, x(340), y(330)+0.5*v, lwd=3)
  
  text(x(360), y(345), "v", cex=2)
  u <- strwidth("v")
  segments(x(360)-u, y(345)+1.5*v, x(360)-u,  y(345)-2.0*v, lty="dotted")
  segments(x(360)+u, y(345)+1.5*v, x(360)+u,  y(345)-2.0*v, lty="dotted")
  arrows  (x(360)+u, y(345)-1.5*v, x(360)-u,  y(345)-1.5*v, len=0.05, lwd=3, code=3)
  segments(x(360), y(345)-1.5*v, x(360), y(335)+0.5*v, lwd=3)
  
  text(x(380), y(345), "i", cex=2)
  u <- strwidth("i")
  segments(x(380)-u, y(345)+1.5*v, x(380)-u,  y(345)-2.0*v, lty="dotted")
  segments(x(380)+u, y(345)+1.5*v, x(380)+u,  y(345)-2.0*v, lty="dotted")
  arrows  (x(380)+u, y(345)-1.5*v, x(380)-u,  y(345)-1.5*v, len=0.05, lwd=3, code=3)
  segments(x(380), y(345)-1.5*v, x(380), y(330)+0.5*v, lwd=3)

  text(x(320), y(335), 'strwidth("W")')
  text(x(340), y(330), 'strwidth("L")')
  text(x(360), y(335), 'strwidth("v")')
  text(x(380), y(330), 'strwidth("i")')
}
draw_framework()
draw_multiline()
ht()
wi()
```

## String size

**strwidth()**

**strheight()**

The text that appears inside your plot (e.g, with the **text()** function) or that appears outside your plot (e.g., your title and axis labels) can vary substantially from one plot to another.

The **strwidth** and **strheight** functions will tell you the size of a specified string in inches (**units="inches"**), user coordinates (**units="user"**) or as a percentage of the graphics device (**units="figure"**).

For a single line of text, **strheight** will give you the height of the letter "M". Watch out as the vertical size of a string will not count the part that letters that descend below the baseline (e.g., "g" or "j").

If you have a string with one of more linebreaks ("\n"), the **strheight** function will measure the height of the letter "M" plus the height of one or more additional lines. The height of a line is dependent on the line spacing, set by the **lheight** argument of **par**. The default line height (**lheight=1**), corresponding to single spaced lines, produces a line height equal to 1.6 times the height of "M".

The **strwidth** function will produce different widths to individual characters, representing the proportional spacing used by most fonts (a "W" using much more space than an "i"). For the width of a string, the **strwidth** function will sum up the lengths of the individual characters in the string.

```{r cin1, fig.width=5.25, fig.height=5.25, echo=FALSE}
cin1 <- function() {
  u <- par("cxy")[1]
  v <- strheight("W")
  
  text(x(320), y(320), "W", cex=2)
  segments(x(320)-u, y(320)+1.5*v, x(320)-u,  y(320)-2.0*v, lty="dotted")
  segments(x(320)+u, y(320)+1.5*v, x(320)+u,  y(320)-2.0*v, lty="dotted")
  arrows  (x(320)+u, y(320)-1.5*v, x(320)-u,  y(320)-1.5*v, len=0.05, lwd=3, code=3)
  segments(x(320), y(320)-1.5*v, x(320), y(308), lwd=3)
  
  text(x(340), y(320), "L", cex=2)
  segments(x(340)-u, y(320)+1.5*v, x(340)-u,  y(320)-2.0*v, lty="dotted")
  segments(x(340)+u, y(320)+1.5*v, x(340)+u,  y(320)-2.0*v, lty="dotted")
  arrows  (x(340)+u, y(320)-1.5*v, x(340)-u,  y(320)-1.5*v, len=0.05, lwd=3, code=3)
  segments(x(340), y(320)-1.5*v, x(340), y(312), lwd=3)
  
  text(x(360), y(320), "v", cex=2)
  segments(x(360)-u, y(320)+1.5*v, x(360)-u,  y(320)-2.0*v, lty="dotted")
  segments(x(360)+u, y(320)+1.5*v, x(360)+u,  y(320)-2.0*v, lty="dotted")
  arrows  (x(360)+u, y(320)-1.5*v, x(360)-u,  y(320)-1.5*v, len=0.05, lwd=3, code=3)
  segments(x(360), y(320)-1.5*v, x(360), y(312), lwd=3)
  
  text(x(380), y(320), "i", cex=2)
  segments(x(380)-u, y(320)+1.5*v, x(380)-u,  y(320)-2.0*v, lty="dotted")
  segments(x(380)+u, y(320)+1.5*v, x(380)+u,  y(320)-2.0*v, lty="dotted")
  arrows  (x(380)+u, y(320)-1.5*v, x(380)-u,  y(320)-1.5*v, len=0.05, lwd=3, code=3)
  segments(x(380), y(320)-1.5*v, x(380), y(312), lwd=3)
  
  st <- "cin[1] (in), cra[1] (px), cxy[1] (user)"
  text(x(390), y(308), st, adj=1)
  segments(x(320), y(312), x(380), y(312), lwd=3)
  segments(x(320), y(308), x(388)-strwidth(st), y(308), lwd=3)
  # W (5), M(4), L(3), J or v (2.67) x or y or z (2.33) r (1.67), I(1)
}
cin2 <- function() {
  text(x(390), u7,  "cin[2] or csi (in), cra[2] (px), cxy[2] (user)", adj=1)
  arrows  (x(310), u[2], x(310), u[4], lwd=3, len=0.05, code=3)
  # segments(x(345),  u56, x(347),  u56, lwd=3)
  segments(x(310),  u34, x(306),  u34, lwd=3)
  segments(x(306),  u34, x(306),  u7,  lwd=3)
  segments(x(306),  u7,  x(308),  u7,  lwd=3)
}
draw_framework()
draw_multiline()
cin2()
cin1()
```

**par("cin")** *(r.o.)*

**par("csi")** *(r.o.)*

**par("cra")** *(r.o.)*

**par("cxy")** *(r.o.)*

You can query the approximate size of individual characters using various **par** arguments. Three of these arguments, cin, cra, and cxy, give the size of the width and height as a vector of length 2. The csi argument gives the height only.

The height is the height of a line and the width is the same



# All the graphs combined

```{r combined, fig.width=5.25, fig.height=5.25, echo=FALSE}
draw_framework()
din()
usr()
mar()
pin()

draw_framework()
draw_multiline()
ht()
wi()
cin2()
cin1()
```

**par("fin")**

**par("fig")**

fin (inches), fig (pct)

Test some of these measures.

```{r compare, fig.width=2.62, fig.height=2.62}
draw_framework()
par("cxy")[1]
strwidth("W")
strwidth("M")
strwidth("I")

par("cin")[1]
par("csi")
strwidth("W", units="in")
strwidth("M", units="in")
strwidth("I", units="in")

par("cra")[1]
strwidth("W", units="figure")
strwidth("M", units="figure")
strwidth("I", units="figure")

par("cxy")[2]
strheight("M")
strheight("M\nM")
strheight("M\nM\nM")
strheight("M\nM") - strheight("M")

par("lheight")
par("cin")[2]
strheight("M", units="in")
strheight("M\nM", units="in")
strheight("M\nM\nM", units="in")
strheight("M\nM", units="in") - strheight("M", units="in")
```

**par("cin")**

**par("cra")**

**par("csi")**

**par("cxy")**

**strwidth(s, units, cex, font, vfont)**

**strheight(s, units, cex, font, vfont)**

The cin, cra, and cxy arguments to par give the approximate width and height of a single letter in inches, pixels, and user coordinates, respectively. The csi argument gives the height only in inches. These arguments are read only and you cannot use them to change the font size. Since letters like "I" and "M" have different widths, the values produced here are crude approximations at best.

The strwidth and strheight functions give the width and height of a string s in user coordinates (units="user"), inches (units="inches") and as a percentage of the graphics window (units="figure").
The strwidth function will properly account for narrow and wide letters in a string. The strheight function gives the same value for each letter (the height of the letter "M") and will understate the height of string that has both descending letters (g, p, etc.) and ascending letters (b, d, etc.). For strings that have one or more linefeeds, strheight will calculate size incorporating the line height value (par("lheight")).
